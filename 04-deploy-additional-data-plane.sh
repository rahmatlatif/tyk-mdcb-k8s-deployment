#!/bin/bash

# === Deploy Additional Tyk Data Plane Script ===
# This script deploys additional data planes with auto-incremented namespaces and ports
# Each data plane connects to the same MDCB control plane

set -e

echo "ðŸŒ Deploying Additional Tyk Data Plane..."
echo "=========================================="

# 1. Count existing data plane namespaces
echo "ðŸ” Checking for existing data plane deployments..."
EXISTING_DPS=$(kubectl get namespaces -o name | grep -c "namespace/tyk-dp" || echo "0")

if [ "$EXISTING_DPS" -eq 0 ]; then
    echo "âš ï¸  No existing data planes found. Please run ./03-deploy-data-plane.sh first."
    exit 1
fi

# Calculate the next data plane number
NEXT_DP_NUM=$((EXISTING_DPS + 1))
NEW_NAMESPACE="tyk-dp-${NEXT_DP_NUM}"
NEW_PORT=$((8080 + EXISTING_DPS))

echo "ðŸ“Š Found $EXISTING_DPS existing data plane(s)"
echo "ðŸ“¦ Creating data plane #${NEXT_DP_NUM} in namespace: ${NEW_NAMESPACE}"
echo "ðŸ”Œ Gateway will use port: ${NEW_PORT}"

# 2. Load environment variables from .env.tyk file
if [ -f ".env.tyk" ]; then
    echo "ðŸ“ Loading environment variables from .env.tyk file..."
    source .env.tyk
fi

# 3. Get USER_API_KEY and ORG_ID from tyk-operator-conf secret
echo "ðŸ”‘ Retrieving credentials from control plane..."
export USER_API_KEY=$(kubectl get secret --namespace tyk-cp tyk-operator-conf -o jsonpath="{.data.TYK_AUTH}" | base64 --decode 2>/dev/null || echo "")
export ORG_ID=$(kubectl get secret --namespace tyk-cp tyk-operator-conf -o jsonpath="{.data.TYK_ORG}" | base64 --decode 2>/dev/null || echo "")

if [ -z "$USER_API_KEY" ] || [ -z "$ORG_ID" ]; then
    echo "âŒ ERROR: Could not retrieve USER_API_KEY or ORG_ID from tyk-operator-conf secret"
    echo "Please ensure the control plane is deployed and the secret exists."
    exit 1
fi

echo "Retrieved USER_API_KEY: ${USER_API_KEY:0:8}..."
echo "Retrieved ORG_ID: $ORG_ID"

# 4. Set group ID for this data plane
export GROUP_ID="dp-${NEXT_DP_NUM}"
echo "ðŸ·ï¸  Using group ID: ${GROUP_ID}"

# 5. Create the new namespace
echo "ðŸ“¦ Creating namespace ${NEW_NAMESPACE}..."
kubectl create namespace ${NEW_NAMESPACE}

# 6. Create the Kubernetes secret for the data plane
echo "ðŸ” Creating data plane secret..."
kubectl create secret generic tyk-data-plane-details \
  --from-literal "orgId=$ORG_ID" \
  --from-literal "userApiKey=$USER_API_KEY" \
  --from-literal "groupID=$GROUP_ID" \
  --namespace ${NEW_NAMESPACE}

# 7. Export the MDCB connection string
export MDCB_CONNECTIONSTRING="mdcb-svc-tyk-cp-tyk-mdcb.tyk-cp.svc:9091"
echo "ðŸ”— MDCB_CONNECTIONSTRING: $MDCB_CONNECTIONSTRING"

# 8. Deploy Redis for this data plane
echo "ðŸ“¦ Deploying Redis for data plane ${NEXT_DP_NUM}..."
REDIS_BITNAMI_CHART_VERSION=19.0.2

helm upgrade tyk-redis oci://registry-1.docker.io/bitnamicharts/redis \
  -n ${NEW_NAMESPACE} \
  --install \
  --version $REDIS_BITNAMI_CHART_VERSION \
  --set image.registry=docker.io \
  --set image.repository=bitnami/redis \
  --set image.tag=latest \
  --set metrics.image.registry=docker.io \
  --set metrics.image.repository=bitnami/redis-exporter \
  --set metrics.image.tag=latest

# 9. Wait for Redis to be ready
echo "â³ Waiting for Redis to be ready..."
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=redis -n ${NEW_NAMESPACE} --timeout=300s

# 10. Retrieve the Redis password
export REDIS_PASSWORD=$(kubectl get secret tyk-redis -n ${NEW_NAMESPACE} -o jsonpath="{.data.redis-password}" | base64 --decode)
echo "ðŸ”‘ Redis password retrieved"

# 11. Create a modified values file for this data plane
echo "ðŸ“ Creating values file for data plane ${NEXT_DP_NUM}..."
cat > values-dp-${NEXT_DP_NUM}.yaml << EOF
# Values for Data Plane ${NEXT_DP_NUM}
# Auto-generated by 04-deploy-additional-data-plane.sh

global:
  components:
    pump: false

  servicePorts:
    gateway: ${NEW_PORT}

  remoteControlPlane:
    useSecretName: tyk-data-plane-details
    enabled: true
    connectionString: "${MDCB_CONNECTIONSTRING}"
    useSSL: false
    sslInsecureSkipVerify: true

  mdcbSynchronizer:
    enabled: false
    keySpaceSyncInterval: 10

  tls:
    gateway: false
    useDefaultTykCertificate: true

  secrets:
    APISecret: CHANGEME
    useSecretName: ""

  redis:
    addrs:
      - tyk-redis-master.${NEW_NAMESPACE}.svc.cluster.local:6379
    passSecret:
      name: tyk-redis
      keyName: redis-password
    storage:
      database: 0

  hashKeys: true

  streaming:
    enabled: true

tyk-gateway:
  nameOverride: ""
  fullnameOverride: ""

  gateway:
    hostName: tyk-gw-${NEXT_DP_NUM}.local
    enableFixedWindowRateLimiter: false

    tls:
      secretName: tyk-default-tls-secret
      insecureSkipVerify: false
      certificatesMountPath: "/etc/certs/tyk-gateway"
      certificates:
        - domain_name: "*"
          cert_file: "/etc/certs/tyk-gateway/tls.crt"
          key_file: "/etc/certs/tyk-gateway/tls.key"

    kind: Deployment
    replicaCount: 1
    podAnnotations: {}
    podLabels: {}
    autoscaling: {}

    image:
      repository: tykio/tyk-gateway
      tag: v5.8.1
      pullPolicy: IfNotPresent

    initContainers:
      setupDirectories:
        repository: busybox
        tag: 1.32
        resources: {}

    imagePullSecrets: []
    containerPort: ${NEW_PORT}

    service:
      type: ClusterIP
      externalTrafficPolicy: Local
      loadBalancerIP: ""
      annotations: {}

    control:
      enabled: false
      containerPort: 9696
      port: 9696
      type: ClusterIP
      annotations: {}

    ingress:
      enabled: false
      className: ""
      annotations: {}
      hosts:
        - host: chart-example.local
          paths:
            - path: /
              pathType: ImplementationSpecific
      tls: []

    pdb:
      enabled: false
      minAvailable: ""
      maxUnavailable: ""

    resources: {}
    livenessProbe: {}
    readinessProbe: {}
    startupProbe: {}

    securityContext:
      runAsUser: 1000
      fsGroup: 2000
      runAsNonRoot: true

    containerSecurityContext:
      runAsNonRoot: true
      runAsUser: 1000
      allowPrivilegeEscalation: false
      privileged: false
      readOnlyRootFilesystem: true
      seccompProfile:
        type: RuntimeDefault
      capabilities:
        drop:
          - ALL

    nodeSelector: {}
    tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
    affinity: {}

    extraContainers: []
    extraEnvs: []

    sharding:
      enabled: false
      tags: ""

    analyticsEnabled: ""
    analyticsConfigType: ""

    opentelemetry:
      enabled: false

    enablePathPrefixMatching: true
    enablePathSuffixMatching: true
    enableStrictRoutes: true

    extraVolumes: []
    extraVolumeMounts: []

    log:
      level: "debug"
      format: "default"

    accessLogs:
      enabled: false

    allowInsecureConfigs: true
    globalSessionLifetime: 100
    enableCustomDomains: true
    maxIdleConnectionsPerHost: 500

tyk-pump:
  pump:
    replicaCount: 0

tests:
  enabled: false
EOF

echo "âœ… Values file created: values-dp-${NEXT_DP_NUM}.yaml"

# 12. Add Tyk Helm repository
echo "ðŸ“š Adding Tyk Helm repository..."
helm repo add tyk-helm https://helm.tyk.io/public/helm/charts/ || true
helm repo update

# 13. Install the data plane
echo "ðŸš€ Installing Tyk Data Plane ${NEXT_DP_NUM}..."
helm upgrade --install tyk-data-plane-${NEXT_DP_NUM} tyk-helm/tyk-data-plane \
  -n ${NEW_NAMESPACE} \
  -f values-dp-${NEXT_DP_NUM}.yaml

echo ""
echo "âœ… Data Plane ${NEXT_DP_NUM} Deployment Complete!"
echo "=========================================="
echo ""
echo "ðŸ“‹ Details:"
echo "  - Namespace: ${NEW_NAMESPACE}"
echo "  - Group ID: ${GROUP_ID}"
echo "  - Gateway Port: ${NEW_PORT}"
echo ""
echo "ðŸ”— To access this gateway:"
echo "  kubectl port-forward -n ${NEW_NAMESPACE} service/gateway-svc-tyk-data-plane-${NEXT_DP_NUM}-tyk-gateway ${NEW_PORT}:${NEW_PORT}"
echo "  curl localhost:${NEW_PORT}/hello"
echo ""
echo "ðŸ“Š View all data planes:"
echo "  kubectl get namespaces | grep tyk-dp"
echo ""

